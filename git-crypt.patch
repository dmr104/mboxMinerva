═══════════════════════════════════════════════════════════════════
mboxMinerva: git-crypt Vault Encryption Enforcement Patchset
═══════════════════════════════════════════════════════════════════

This patchset enforces git-crypt encryption for vault/ at ingestion,
DSR operations, and CI/CD, ensuring PII pseudonym mappings are never
committed unencrypted.

───────────────────────────────────────────────────────────────────
FILE: .gitattributes
───────────────────────────────────────────────────────────────────
# Enforce git-crypt encryption for vault/ (PII pseudonym mappings)
# All files under vault/ are automatically encrypted when staged
vault/** filter=git-crypt diff=git-crypt

# Prevent accidental commits of sensitive patterns
*.key filter=git-crypt diff=git-crypt
*.pem filter=git-crypt diff=git-crypt
*_secrets.yml filter=git-crypt diff=git-crypt

───────────────────────────────────────────────────────────────────
FILE: lib/vault_guard.rb
───────────────────────────────────────────────────────────────────
# frozen_string_literal: true

require 'fileutils'
require 'open3'

##
# VaultGuard: Enforces git-crypt encryption for vault/ before any I/O.
#
# Usage:
#   VaultGuard.ensure_unlocked!(vault_dir: 'vault/')
#
# Raises RuntimeError if:
#   - git-crypt is not installed
#   - vault/ is locked (encrypted on disk)
#   - .git-crypt/ keyring is missing (repo not initialized)
#
# Security rationale:
#   Fail-fast prevents accidental writes to locked vault (would corrupt
#   encrypted files) or reads of uninitialized vault (leaks plaintext).
module VaultGuard
  DEFAULT_VAULT_DIR = 'vault'

  class << self
    ##
    # Ensures vault is unlocked and git-crypt is operational.
    # Raises RuntimeError with actionable message if checks fail.
    def ensure_unlocked!(vault_dir: DEFAULT_VAULT_DIR)
      check_git_crypt_installed!
      check_repo_initialized!
      check_vault_unlocked!(vault_dir)
    end

    private

    def check_git_crypt_installed!
      stdout, status = Open3.capture2('git-crypt', '--version')
      return if status.success?

      raise <<~ERROR
        git-crypt not found. Install via:
          Debian/Ubuntu: sudo apt-get install git-crypt
          macOS:         brew install git-crypt
          RHEL/CentOS:   sudo yum install git-crypt
      ERROR
    rescue Errno::ENOENT
      raise 'git-crypt not found in PATH. Install git-crypt first.'
    end

    def check_repo_initialized!
      return if File.directory?('.git-crypt')

      raise <<~ERROR
        git-crypt not initialized. Run:
          git-crypt init
          git-crypt export-key .git-crypt-key
        Store .git-crypt-key securely (e.g., password manager, CI secret).
        Collaborators unlock via: git-crypt unlock .git-crypt-key
      ERROR
    end

    def check_vault_unlocked!(vault_dir)
      # Create vault/ if missing (first run)
      FileUtils.mkdir_p(vault_dir) unless Dir.exist?(vault_dir)

      # Write sentinel file and check if it's encrypted
      sentinel = File.join(vault_dir, '.unlock_check')
      File.write(sentinel, 'unlocked')
      content = File.binread(sentinel)

      # If git-crypt is locked, file will contain binary garbage (NUL bytes)
      if content.include?("\x00") || content != 'unlocked'
        raise <<~ERROR
          vault/ is LOCKED (encrypted on disk). Unlock via:
            git-crypt unlock .git-crypt-key
          Then retry. Never commit while locked (corrupts encrypted files).
        ERROR
      end
    ensure
      File.delete(sentinel) if sentinel && File.exist?(sentinel)
    end
  end
end

───────────────────────────────────────────────────────────────────
FILE: lib/pii_scrubber.rb (UPDATED)
───────────────────────────────────────────────────────────────────
# frozen_string_literal: true

require 'digest'
require 'json'
require 'fileutils'
require_relative 'vault_guard'

##
# PIIScrubber: Deterministic pseudonymization with encrypted vault storage.
#
# Usage:
#   scrubber = PIIScrubber.new(vault_dir: 'vault/', seed: 42)
#   scrubbed = scrubber.scrub_email(raw_email_text)
#   scrubber.save_vault  # Commit mappings to encrypted vault
#
# Enforces git-crypt encryption via VaultGuard before any vault I/O.
class PIIScrubber
  EMAIL_REGEX = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/
  IP_REGEX = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/
  
  attr_reader :vault_dir, :seed

  def initialize(vault_dir: 'vault/', seed: 42)
    @vault_dir = vault_dir
    @seed = seed
    @email_map = {}
    @ip_map = {}
    @rng = Random.new(seed)

    # ENFORCE: git-crypt must be unlocked before loading/saving vault
    VaultGuard.ensure_unlocked!(vault_dir: vault_dir)

    load_vault
  end

  ##
  # Scrubs email addresses and IPs with deterministic pseudonyms.
  # Same input → same pseudonym (seeded hash).
  def scrub_email(text)
    text = text.dup
    text.gsub!(EMAIL_REGEX) { |email| pseudonymize_email(email) }
    text.gsub!(IP_REGEX) { |ip| pseudonymize_ip(ip) }
    text
  end

  ##
  # Reverse lookup: pseudonym → original (for DSR export).
  # Returns nil if pseudonym not found.
  def reverse_lookup_email(pseudo)
    @email_map.key(pseudo)
  end

  def reverse_lookup_ip(pseudo)
    @ip_map.key(pseudo)
  end

  ##
  # Saves mappings to encrypted vault (git-crypt enforced).
  # Call after scrubbing batch to persist new pseudonyms.
  def save_vault
    VaultGuard.ensure_unlocked!(vault_dir: vault_dir)
    FileUtils.mkdir_p(vault_dir)

    File.write(File.join(vault_dir, 'email_map.json'), JSON.pretty_generate(@email_map))
    File.write(File.join(vault_dir, 'ip_map.json'), JSON.pretty_generate(@ip_map))
    File.write(File.join(vault_dir, 'seed.txt'), @seed.to_s)
  end

  private

  def load_vault
    email_file = File.join(vault_dir, 'email_map.json')
    ip_file = File.join(vault_dir, 'ip_map.json')
    seed_file = File.join(vault_dir, 'seed.txt')

    @email_map = File.exist?(email_file) ? JSON.parse(File.read(email_file)) : {}
    @ip_map = File.exist?(ip_file) ? JSON.parse(File.read(ip_file)) : {}

    if File.exist?(seed_file)
      stored_seed = File.read(seed_file).to_i
      if stored_seed != @seed
        warn "[WARN] Vault seed mismatch: stored=#{stored_seed}, requested=#{@seed}. Using stored."
        @seed = stored_seed
        @rng = Random.new(@seed)
      end
    end
  end

  def pseudonymize_email(email)
    @email_map[email] ||= generate_pseudonym("email_#{email}")
  end

  def pseudonymize_ip(ip)
    @ip_map[ip] ||= generate_pseudonym("ip_#{ip}")
  end

  def generate_pseudonym(input)
    # Deterministic hash: seed + input → stable pseudonym
    hash = Digest::SHA256.hexdigest("#{@seed}:#{input}")[0..15]
    "REDACTED_#{hash}"
  end
end

───────────────────────────────────────────────────────────────────
FILE: lib/dsr_helpers.rb (UPDATED)
───────────────────────────────────────────────────────────────────
# frozen_string_literal: true

require 'json'
require 'digest'
require 'fileutils'
require_relative 'pii_scrubber'
require_relative 'vault_guard'

##
# DSRHelpers: GDPR/CCPA Data Subject Request utilities.
#
# Enforces git-crypt vault encryption before any pseudonym lookups.
module DSRHelpers
  ##
  # Reverse-lookup pseudonyms for a given email (export use case).
  # Returns array of thread_ids containing the email.
  def self.locate_email(email, manifest_path:, vault_dir: 'vault/', seed: 42)
    VaultGuard.ensure_unlocked!(vault_dir: vault_dir)
    scrubber = PIIScrubber.new(vault_dir: vault_dir, seed: seed)
    pseudo = scrubber.instance_variable_get(:@email_map)[email]
    return [] unless pseudo

    manifest = JSON.parse(File.read(manifest_path))
    threads = []
    manifest['threads'].each do |thread|
      threads << thread['thread_id'] if thread['content'].include?(pseudo)
    end
    threads
  end

  ##
  # Write tombstone for a thread_id (deletion use case).
  # Tombstones are plain JSON (no PII), safe to commit unencrypted.
  def self.tombstone_thread(thread_id, manifest_path:, reason: 'DSR deletion')
    tombstone_dir = File.join(File.dirname(manifest_path), 'tombstones')
    FileUtils.mkdir_p(tombstone_dir)

    tombstone = {
      thread_id: thread_id,
      deleted_at: Time.now.utc.iso8601,
      reason: reason
    }

    tombstone_file = File.join(tombstone_dir, "#{thread_id}.json")
    File.write(tombstone_file, JSON.pretty_generate(tombstone))
    tombstone_file
  end

  ##
  # Export thread content with pseudonyms reversed (if vault permits).
  # Returns hash: { thread_id:, content:, reversed: bool }
  def self.export_thread(thread_id, manifest_path:, vault_dir: 'vault/', seed: 42, reverse: true)
    VaultGuard.ensure_unlocked!(vault_dir: vault_dir) if reverse

    manifest = JSON.parse(File.read(manifest_path))
    thread = manifest['threads'].find { |t| t['thread_id'] == thread_id }
    return nil unless thread

    content = thread['content']
    reversed_content = content

    if reverse
      scrubber = PIIScrubber.new(vault_dir: vault_dir, seed: seed)
      email_map = scrubber.instance_variable_get(:@email_map)
      ip_map = scrubber.instance_variable_get(:@ip_map)

      # Reverse substitution: REDACTED_xyz → original
      email_map.each { |orig, pseudo| reversed_content.gsub!(pseudo, orig) }
      ip_map.each { |orig, pseudo| reversed_content.gsub!(pseudo, orig) }
    end

    {
      thread_id: thread_id,
      content: reversed_content,
      reversed: reverse
    }
  end
end

───────────────────────────────────────────────────────────────────
FILE: bin/dsr_export (UPDATED)
───────────────────────────────────────────────────────────────────
#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require_relative '../lib/dsr_helpers'
require_relative '../lib/vault_guard'

options = {
  email: nil,
  manifest: 'data/manifest.json',
  vault_dir: 'vault/',
  seed: 42,
  threads: nil,
  reverse: true
}

OptionParser.new do |opts|
  opts.banner = 'Usage: bin/dsr_export --email user@example.com [options]'

  opts.on('--email EMAIL', 'Email to export') { |v| options[:email] = v }
  opts.on('--threads ID1,ID2', 'Export specific thread IDs (comma-separated)') { |v| options[:threads] = v.split(',') }
  opts.on('--manifest PATH', 'Manifest path') { |v| options[:manifest] = v }
  opts.on('--vault-dir DIR', 'Vault directory') { |v| options[:vault_dir] = v }
  opts.on('--seed SEED', Integer, 'Vault seed') { |v| options[:seed] = v }
  opts.on('--[no-]reverse', 'Reverse pseudonyms (default: true)') { |v| options[:reverse] = v }
end.parse!

# Enforce git-crypt before any vault access
if options[:reverse]
  VaultGuard.ensure_unlocked!(vault_dir: options[:vault_dir])
end

thread_ids = if options[:threads]
               options[:threads]
             elsif options[:email]
               DSRHelpers.locate_email(
                 options[:email],
                 manifest_path: options[:manifest],
                 vault_dir: options[:vault_dir],
                 seed: options[:seed]
               )
             else
               abort 'Specify --email or --threads'
             end

if thread_ids.empty?
  puts 'No threads found for given email.'
  exit 0
end

puts "Exporting #{thread_ids.size} thread(s):"
thread_ids.each do |tid|
  export = DSRHelpers.export_thread(
    tid,
    manifest_path: options[:manifest],
    vault_dir: options[:vault_dir],
    seed: options[:seed],
    reverse: options[:reverse]
  )
  next unless export

  puts "\n=== Thread: #{tid} ==="
  puts export[:content]
  puts "(Reversed: #{export[:reversed]})"
end

───────────────────────────────────────────────────────────────────
FILE: bin/dsr_delete (UPDATED)
───────────────────────────────────────────────────────────────────
#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require_relative '../lib/dsr_helpers'
require_relative '../lib/vault_guard'

options = {
  email: nil,
  manifest: 'data/manifest.json',
  vault_dir: 'vault/',
  seed: 42,
  threads: nil,
  dry_run: false,
  reason: 'GDPR Art. 17 - Right to erasure'
}

OptionParser.new do |opts|
  opts.banner = 'Usage: bin/dsr_delete --email user@example.com [options]'

  opts.on('--email EMAIL', 'Email to delete') { |v| options[:email] = v }
  opts.on('--threads ID1,ID2', 'Delete specific thread IDs') { |v| options[:threads] = v.split(',') }
  opts.on('--manifest PATH', 'Manifest path') { |v| options[:manifest] = v }
  opts.on('--vault-dir DIR', 'Vault directory') { |v| options[:vault_dir] = v }
  opts.on('--seed SEED', Integer, 'Vault seed') { |v| options[:seed] = v }
  opts.on('--dry-run', 'Preview without writing tombstones') { options[:dry_run] = true }
  opts.on('--reason REASON', 'Deletion reason') { |v| options[:reason] = v }
end.parse!

# Enforce git-crypt before vault lookup
VaultGuard.ensure_unlocked!(vault_dir: options[:vault_dir])

thread_ids = if options[:threads]
               options[:threads]
             elsif options[:email]
               DSRHelpers.locate_email(
                 options[:email],
                 manifest_path: options[:manifest],
                 vault_dir: options[:vault_dir],
                 seed: options[:seed]
               )
             else
               abort 'Specify --email or --threads'
             end

if thread_ids.empty?
  puts 'No threads found for given email.'
  exit 0
end

puts "#{options[:dry_run] ? '[DRY RUN]' : '[LIVE]'} Deleting #{thread_ids.size} thread(s):"
thread_ids.each do |tid|
  if options[:dry_run]
    puts "  Would tombstone: #{tid}"
  else
    path = DSRHelpers.tombstone_thread(
      tid,
      manifest_path: options[:manifest],
      reason: options[:reason]
    )
    puts "  Tombstoned: #{tid} → #{path}"
  end
end

puts "\nNext steps:" unless options[:dry_run]
puts '  1. Retrain with --respect-tombstones=true'
puts '  2. git add data/tombstones/ && git commit'

───────────────────────────────────────────────────────────────────
FILE: scripts/ci_unlock_vault.sh
───────────────────────────────────────────────────────────────────
#!/usr/bin/env bash
# CI helper: Unlock git-crypt vault using secret key from CI variable.
#
# Usage (GitLab CI):
#   GIT_CRYPT_KEY_BASE64=$GIT_CRYPT_KEY_BASE64 ./scripts/ci_unlock_vault.sh
#
# Prerequisites:
#   - Set CI/CD variable GIT_CRYPT_KEY_BASE64 (masked, protected)
#   - Generate via: base64 -w0 .git-crypt-key

set -euo pipefail

if [[ -z "${GIT_CRYPT_KEY_BASE64:-}" ]]; then
  echo "ERROR: GIT_CRYPT_KEY_BASE64 not set. Configure in CI/CD settings." >&2
  exit 1
fi

# Decode key to temp file (secure tmpfs)
KEY_FILE=$(mktemp)
trap "rm -f $KEY_FILE" EXIT
echo "$GIT_CRYPT_KEY_BASE64" | base64 -d > "$KEY_FILE"

# Unlock vault
git-crypt unlock "$KEY_FILE"
echo "✓ vault/ unlocked successfully"

# Verify unlock
if [[ ! -d vault/ ]]; then
  echo "WARN: vault/ does not exist yet (first run?)"
  exit 0
fi

# Check sentinel
ruby -e "
require_relative 'lib/vault_guard'
VaultGuard.ensure_unlocked!(vault_dir: 'vault/')
puts '✓ Vault unlock verified'
"

───────────────────────────────────────────────────────────────────
FILE: scripts/setup_git_crypt.sh
───────────────────────────────────────────────────────────────────
#!/usr/bin/env bash
# First-time setup: Initialize git-crypt and export key.
#
# Usage:
#   ./scripts/setup_git_crypt.sh
#
# Output:
#   - .git-crypt-key (store in password manager + CI secret)
#   - .gitattributes (committed with vault/** filter)

set -euo pipefail

echo "=== mboxMinerva: git-crypt setup ==="

# Check if git-crypt is installed
if ! command -v git-crypt &>/dev/null; then
  echo "ERROR: git-crypt not found. Install via:"
  echo "  Debian/Ubuntu: sudo apt-get install git-crypt"
  echo "  macOS:         brew install git-crypt"
  exit 1
fi

# Initialize git-crypt
if [[ -d .git-crypt ]]; then
  echo "✓ git-crypt already initialized"
else
  git-crypt init
  echo "✓ git-crypt initialized"
fi

# Export key
if [[ -f .git-crypt-key ]]; then
  echo "✓ .git-crypt-key already exists"
else
  git-crypt export-key .git-crypt-key
  echo "✓ Key exported to .git-crypt-key"
fi

# Ensure .gitattributes exists
if [[ ! -f .gitattributes ]]; then
  cat > .gitattributes <<'EOF'
# Enforce git-crypt encryption for vault/ (PII pseudonym mappings)
vault/** filter=git-crypt diff=git-crypt

# Prevent accidental commits of sensitive patterns
*.key filter=git-crypt diff=git-crypt
*.pem filter=git-crypt diff=git-crypt
*_secrets.yml filter=git-crypt diff=git-crypt
EOF
  git add .gitattributes
  echo "✓ .gitattributes created (commit it)"
fi

# Create vault/ directory
mkdir -p vault/
echo "unlocked" > vault/.unlock_check
git add vault/.unlock_check

echo ""
echo "=== NEXT STEPS ==="
echo "1. Store .git-crypt-key securely (password manager)"
echo "2. Add to CI/CD as GIT_CRYPT_KEY_BASE64:"
echo "     base64 -w0 .git-crypt-key"
echo "3. Collaborators unlock via:"
echo "     git-crypt unlock .git-crypt-key"
echo "4. Commit .gitattributes:"
echo "     git commit -m 'Add git-crypt vault encryption'"

───────────────────────────────────────────────────────────────────
FILE: .gitlab-ci.yml (UPDATED - add vault unlock before test stage)
───────────────────────────────────────────────────────────────────
# Insert this BEFORE the test:ruby job's script section:

variables:
  # Unlock vault in CI (requires GIT_CRYPT_KEY_BASE64 secret)
  GIT_CRYPT_UNLOCK: "true"

before_script:
  # Unlock git-crypt vault if GIT_CRYPT_KEY_BASE64 is set
  - |
    if [[ "$GIT_CRYPT_UNLOCK" == "true" ]] && [[ -n "${GIT_CRYPT_KEY_BASE64:-}" ]]; then
      apt-get update -qq && apt-get install -y -qq git-crypt
      ./scripts/ci_unlock_vault.sh
    fi

# Then in test:ruby job, add:
test:ruby:
  stage: test
  image: ruby:3.2
  before_script:
    - apt-get update -qq && apt-get install -y -qq git-crypt
    - ./scripts/ci_unlock_vault.sh
    - bundle install --jobs $(nproc) --path vendor
  script:
    - bundle exec rspec --format documentation --format RspecJunitFormatter --out junit.xml
  artifacts:
    reports:
      junit: junit.xml

───────────────────────────────────────────────────────────────────
FILE: docs/vault_encryption.md
───────────────────────────────────────────────────────────────────
# Vault Encryption with git-crypt

## Overview

mboxMinerva stores PII pseudonym mappings in `vault/` (email→REDACTED_xyz).
**All vault files are encrypted at rest via git-crypt** to prevent accidental
plaintext commits.

## Architecture

```
┌─────────────────┐
│ git-crypt init  │  One-time setup: generates symmetric key
└────────┬────────┘
         │
         v
┌─────────────────────────────────────────────────────────────┐
│ .gitattributes: vault/** filter=git-crypt diff=git-crypt   │
│   → All vault/ files encrypted on `git add`                │
└────────┬────────────────────────────────────────────────────┘
         │
         v
┌──────────────────────────────────────────────────────────────┐
│ VaultGuard.ensure_unlocked! (lib/vault_guard.rb)            │
│   → Enforces unlock before PIIScrubber / DSRHelpers I/O     │
│   → Writes sentinel, checks for binary garbage              │
│   → Raises if locked (prevents corruption)                  │
└────────┬─────────────────────────────────────────────────────┘
         │
         v
┌──────────────────────────────────────────────────────────────┐
│ CI/CD: scripts/ci_unlock_vault.sh                           │
│   → Decodes GIT_CRYPT_KEY_BASE64 secret                     │
│   → Runs `git-crypt unlock` before tests                    │
└──────────────────────────────────────────────────────────────┘
```

## Setup (First Time)

```bash
# 1. Install git-crypt
sudo apt-get install git-crypt  # Debian/Ubuntu
brew install git-crypt          # macOS

# 2. Run setup script
./scripts/setup_git_crypt.sh

# 3. Store .git-crypt-key securely (password manager)
# 4. Add to CI/CD as GIT_CRYPT_KEY_BASE64 (masked, protected):
base64 -w0 .git-crypt-key

# 5. Commit .gitattributes
git add .gitattributes vault/.unlock_check
git commit -m "Add git-crypt vault encryption"
```

## Collaborator Onboarding

```bash
# Obtain .git-crypt-key from team lead (secure channel)
git-crypt unlock /path/to/.git-crypt-key

# Verify unlock
ruby -e "require_relative 'lib/vault_guard'; VaultGuard.ensure_unlocked!"
```

## CI/CD Integration

Add to `.gitlab-ci.yml`:

```yaml
variables:
  GIT_CRYPT_UNLOCK: "true"

before_script:
  - apt-get update -qq && apt-get install -y -qq git-crypt
  - ./scripts/ci_unlock_vault.sh
```

**CI Secret**: Set `GIT_CRYPT_KEY_BASE64` in GitLab CI/CD Settings →
Variables (masked + protected branches only).

## Security Properties

| Threat | Mitigation |
|--------|-----------|
| Plaintext vault commit | git-crypt encrypts on `git add` (transparent) |
| Locked vault corruption | VaultGuard fails before write |
| Key leak in CI logs | Key decoded to tmpfs, deleted after unlock |
| Unauthorized access | Protected branch + masked CI variable |
| Forgotten unlock | All PII tools call `VaultGuard.ensure_unlocked!` |

## Threat Model

**In Scope**:
- Accidental plaintext commit of vault/ (MITIGATED: git-crypt auto-encrypts)
- CI pipeline accessing vault (MITIGATED: unlock script + secret)
- Corrupted vault from write-while-locked (MITIGATED: VaultGuard sentinel check)

**Out of Scope** (manual operational security):
- .git-crypt-key stored unencrypted on disk (use password manager)
- Compromised developer machine (full disk encryption recommended)
- Vault access by unauthorized collaborators (GPG multi-user mode available but not configured)

## Troubleshooting

### Error: "vault/ is LOCKED"
```bash
git-crypt unlock .git-crypt-key
ruby -e "require_relative 'lib/vault_guard'; VaultGuard.ensure_unlocked!"
```

### Error: "git-crypt not initialized"
```bash
./scripts/setup_git_crypt.sh
```

### CI Error: "GIT_CRYPT_KEY_BASE64 not set"
1. Generate: `base64 -w0 .git-crypt-key`
2. GitLab: Settings → CI/CD → Variables → Add variable
   - Key: `GIT_CRYPT_KEY_BASE64`
   - Value: (paste base64 output)
   - Flags: ✓ Masked, ✓ Protected

### Verify Encryption on Disk
```bash
# Lock vault (simulate fresh clone)
git-crypt lock

# Check raw file (should be binary garbage)
file vault/email_map.json  # → "data"
hexdump -C vault/email_map.json | head  # → binary blob

# Unlock
git-crypt unlock .git-crypt-key
cat vault/email_map.json  # → readable JSON
```

## References

- git-crypt docs: https://github.com/AGWA/git-crypt
- Threat model: docs/data_safety.md
- VaultGuard implementation: lib/vault_guard.rb

═══════════════════════════════════════════════════════════════════
END OF PATCHSET
═══════════════════════════════════════════════════════════════════

## Quick Start

1. Apply .gitattributes, lib/vault_guard.rb, scripts/*.sh
2. Run: ./scripts/setup_git_crypt.sh
3. Update lib/pii_scrubber.rb, lib/dsr_helpers.rb, bin/dsr_*
4. Add GIT_CRYPT_KEY_BASE64 to CI secrets (base64 -w0 .git-crypt-key)
5. Test: ruby -e "require_relative 'lib/vault_guard'; VaultGuard.ensure_unlocked!"

All files include inline comments explaining security rationale.