# .gitlab-ci.yml — mboxMinerva CI/CD Pipeline with git-crypt enforcement
# ============================================================================
# Stages: lint → test → security → build → release
# New: git-crypt unlock before any job that touches vault/ or PII modules
# Required CI/CD Variables (Settings → CI/CD → Variables):
#   - GPG_PRIVATE_KEY: base64-encoded GPG private key (git-crypt unlock)
#   - GPG_PASSPHRASE: passphrase for the GPG key (if protected)
# ============================================================================



stages:
  - build_infra
  - app_test
  - deploy

variables:
  # Disable per-build isolation so that we can see the previous images on the host
  FF_NETWORK_PER_BUILD: "false"
  VAULT_ADDR: "http://192.168.1.168:8200"
  GH_USER_NAME: "dmr104"
  CONTAINER_REGISTRY: "ghcr.io"
  TAG_IMMUTABLE: $CI_COMMIT_SHORT_SHA

# secret_fetcher (the gitlab-runner will spin up separate job containers on the host using a podman executor, so we NEED an image for those job containers "alpine:latest" which by default will come from docker.io registry)
.secret_fetcher:
  image: openbao/openbao:latest # Gives us the `bao` command
  variables:
    PATH_OF_SECRET: "github-creds"   # This must match the name of our secret with OpenBao's secret engine.
    VAULT_ROLE: "gitlab-dev-runner-role"
  id_tokens:
    # This generates the JWT. 
    BAO_VAULT_ID:
      aud: "my-super-secure-app-id"  # The 'aud' MUST match OpenBao's 'bound-audiences'

  script: 
    - echo "Authentifying to OpenBao..."

    # 1. Login to OpenBao
    # We send the variable $BAO_VAULT_ID to OpenBao via **`id_tokens`** which is a signed JWT embedding with aud (audience).
    - echo "Vault role is $VAULT_ROLE"
    - export VAULT_TOKEN=$(bao write -field=token auth/jwt/login role=$VAULT_ROLE jwt=$BAO_VAULT_ID)
    - echo "I have the VAULT_TOKEN! It is $(echo "${VAULT_TOKEN}" | cut -c 1-3)xxx"

    # 2. Fetch the GHCR_PAT secret.
    - echo "Fetching secrets from ${PATH_OF_SECRET}"
    - export GHCR_PAT=$(bao kv get -mount=secret -field=pat $PATH_OF_SECRET)
    - echo "I have the secret! It is $(echo "${GHCR_PAT}" | cut -c 1-3)xxx"

# JOB 1: The Builder
# Usage: Builds the image ONLY if you touch files in 'docker/'
rebuild_ruby_base:
  extends: .secret_fetcher  # <--- Pulls in variables from .secret_fetcher
  stage: build_infra
    # Inherits the `openbao/openbao:latest` image from .secret_fetcher (so that `bao` auth tool is native). 
  variables:
    # Disable TLS since we are talking to a local Unix socket
    DOCKER_TLS_CERTDIR: ""
  before_script: 
    # Install the docker client utility on top of openbao (`apk add --no-cache docker-cli`), so that the image will be able to talk to our /var/run/docker.sock (podman) in the GitLab Runner which is mapped to $XDG_RUNTIME_DIR"/podman/podman.sock in the Host (see INITIAL_SETUP/Gitlab.sh)
    - apk add --no-cache docker-cli
  script:
    # Step 1: Run the inherited secret_fetcher script to get GHCR_PAT
    - !reference [.secret_fetcher, script]  # <---  Pulls in script from .secret_fetcher

    # Step 2. Clear the vault token (good hygiene)
    - unset VAULT_TOKEN
    - echo "I have the GHCR_PAT! It is $(echo "{$GHCR_PAT}" | cut -c 1-3)xxx"

    # Step 3. Build and push
    - echo "Detected changes in build context. Rebuilding base image on Host..."
    # This 'docker build' actually runs on the HOST machine because of the socket mapping.
    # It updates the 'ruby:local-patched' tag in the host's storage.
    - docker build --pull -t ruby:local-patched -f docker/Dockerfile . 
    - echo "Have built ruby image from Dockerfile" 
    - docker tag ruby:local-patched "$CONTAINER_REGISTRY/$GH_USER_NAME"/ruby:"$TAG_IMMUTABLE" 
    - docker tag ruby:local-patched "$CONTAINER_REGISTRY/$GH_USER_NAME"/ruby:remote-patched

    # Step 4. Auth and push to GHCR
    - "echo \"Authentifying to ${CONTAINER_REGISTRY}\"" 
    - echo "$GHCR_PAT" | docker login $CONTAINER_REGISTRY -u $GH_USER_NAME --password-stdin 
    - "echo \"Authentified via docker to ${CONTAINER_REGISTRY}\"" 
    - "echo \"Pushing ruby:local-patched to ${CONTAINER_REGISTRY}\"" 
    - docker push "$CONTAINER_REGISTRY"/"$GH_USER_NAME"/ruby:"$TAG_IMMUTABLE" 
    - docker push "$CONTAINER_REGISTRY"/"$GH_USER_NAME"/ruby:remote-patched 
  rules:
    # CONDITION: Only run if these files change in the commit/MR
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - docker/Dockerfile
        - docker/**/*
    # FALLBACK: Allow manual triggering in the UI if you ever need to force a rebuild (e.g. clean host)
      when: manual                # <--- You must click "Play" in the UI.
    #  allow_failure: false        # The pipeline blocks here until you tell it to proceed.

# JOB 2: The Consumer
# Usage: Runs your actual tests using the image from Job 1
run_tests:
  stage: app_test
  # Because of pull_policy = ["if-not-present"], the Runner looks for this tag
  # on the host first. If Job 1 ran, it sees the new one. If Job 1 skipped, it sees the old one.
  image: 
     name: "${CONTAINER_REGISTRY}/${GH_USER_NAME}/ruby:remote-patched"
  script:
    - ruby -v
    - echo "Running tests in the custom container..."
    # - bundle install
    # - rspec 

.deploy_template:
  variables:
    USE_TAG: "da800744"
  image: "${CONTAINER_REGISTRY}/${GH_USER_NAME}/ruby:${USE_TAG}"
  script:
    - echo "Deploying image ${CONTAINER_REGISTRY}/${GH_USER_NAME}/ruby:${USE_TAG}"
    - "echo \"Targeting environment: ${TARGET_ENV}\""
    # - ./deploy_script.sh --env $TARGET_ENV --tag $CI_COMMIT_SHORT_SHA

# DEV Job: Inherits logic, set ENV to 'staging', runs Automatically
deploy_dev:
  extends: .deploy_template
  stage: deploy
  variables:
    TARGET_ENV: "staging"  # <--- The "Flag" is hardcoded here
  environment:
    name: staging
    # url: https://dev.example.com
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

deploy_prod:
  extends: .deploy_template
  stage: deploy
  variables:
    TARGET_ENV: "production"  # <--- The "Flag" is hardcoded here
  environment:
    name: production
    # url: https://example.com
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual  # <--- The safety gate